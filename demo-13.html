<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo 13 - Logo Particules</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        .hero {
            position: relative;
            height: 100vh;
            background: radial-gradient(ellipse at center, #0a3a9d 0%, #032374 50%, #021654 100%);
            overflow: hidden;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .hero-content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            color: white;
            padding: 2rem;
            padding-top: 55vh;
        }
        .hero-title {
            font-family: 'Roboto', sans-serif;
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #ffffff;
        }
        .hero-subtitle {
            font-family: 'Roboto', sans-serif;
            font-size: 1rem;
            margin-top: 0.5rem;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <section class="hero">
        <div id="canvas-container"></div>
        <div class="hero-content">
            <h1 class="hero-title">Nice Volley Ball</h1>
            <p class="hero-subtitle">Saison 2024-2025</p>
        </div>
    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Create circular logo outline with particles
        const particleCount = 500;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const originalPositions = new Float32Array(particleCount * 3);

        // Colors
        const colorPrimary = new THREE.Color(0xb8e0f7);
        const colorAccent = new THREE.Color(0xdcaf4d);
        const colorWhite = new THREE.Color(0xffffff);

        for (let i = 0; i < particleCount; i++) {
            let x, y, z;

            if (i < 150) {
                // Outer circle
                const angle = (i / 150) * Math.PI * 2;
                const radius = 3;
                x = Math.cos(angle) * radius;
                y = Math.sin(angle) * radius;
                z = 0;
                colorAccent.toArray(colors, i * 3);
            } else if (i < 280) {
                // Inner circle (volleyball)
                const angle = ((i - 150) / 130) * Math.PI * 2;
                const radius = 2;
                x = Math.cos(angle) * radius;
                y = Math.sin(angle) * radius;
                z = 0;
                colorWhite.toArray(colors, i * 3);
            } else if (i < 350) {
                // Horizontal seam
                const t = (i - 280) / 70;
                x = (t - 0.5) * 4;
                y = Math.sin(t * Math.PI) * 0.8;
                z = 0;
                colorPrimary.toArray(colors, i * 3);
            } else if (i < 420) {
                // Vertical seam
                const t = (i - 350) / 70;
                y = (t - 0.5) * 4;
                x = Math.sin(t * Math.PI) * 0.6;
                z = 0;
                colorPrimary.toArray(colors, i * 3);
            } else {
                // Random particles around
                const angle = Math.random() * Math.PI * 2;
                const radius = 2.5 + Math.random() * 1;
                x = Math.cos(angle) * radius;
                y = Math.sin(angle) * radius;
                z = (Math.random() - 0.5) * 0.5;
                colorPrimary.toArray(colors, i * 3);
            }

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            originalPositions[i * 3] = x;
            originalPositions[i * 3 + 1] = y;
            originalPositions[i * 3 + 2] = z;

            sizes[i] = 0.05 + Math.random() * 0.05;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // Custom shader for particles
        const material = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(geometry, material);
        particles.position.y = 1;
        scene.add(particles);

        // Add connecting lines for logo structure
        const lineGroup = new THREE.Group();

        // Outer ring line
        const outerRing = new THREE.EllipseCurve(0, 0, 3, 3, 0, Math.PI * 2, false, 0);
        const outerPoints = outerRing.getPoints(64).map(p => new THREE.Vector3(p.x, p.y, 0));
        const outerGeo = new THREE.BufferGeometry().setFromPoints(outerPoints);
        const outerLine = new THREE.LineLoop(outerGeo, new THREE.LineBasicMaterial({
            color: 0xdcaf4d,
            transparent: true,
            opacity: 0.3
        }));
        lineGroup.add(outerLine);

        // Inner ring
        const innerRing = new THREE.EllipseCurve(0, 0, 2, 2, 0, Math.PI * 2, false, 0);
        const innerPoints = innerRing.getPoints(48).map(p => new THREE.Vector3(p.x, p.y, 0));
        const innerGeo = new THREE.BufferGeometry().setFromPoints(innerPoints);
        const innerLine = new THREE.LineLoop(innerGeo, new THREE.LineBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.2
        }));
        lineGroup.add(innerLine);

        lineGroup.position.y = 1;
        scene.add(lineGroup);

        camera.position.z = 8;

        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
            mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
        });

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            // Animate particles
            const pos = geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                const ox = originalPositions[i * 3];
                const oy = originalPositions[i * 3 + 1];
                const oz = originalPositions[i * 3 + 2];

                // Add subtle movement
                pos[i * 3] = ox + Math.sin(time * 2 + i * 0.1) * 0.05;
                pos[i * 3 + 1] = oy + Math.cos(time * 2 + i * 0.1) * 0.05;
                pos[i * 3 + 2] = oz + Math.sin(time + i) * 0.02;
            }
            geometry.attributes.position.needsUpdate = true;

            // Rotate based on mouse
            particles.rotation.y = mouseX * 0.5;
            particles.rotation.x = mouseY * 0.3;
            lineGroup.rotation.y = mouseX * 0.5;
            lineGroup.rotation.x = mouseY * 0.3;

            // Float animation
            particles.position.y = 1 + Math.sin(time * 0.8) * 0.15;
            lineGroup.position.y = particles.position.y;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
